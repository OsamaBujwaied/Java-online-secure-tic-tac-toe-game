package Complete_Game_Simple_Illustration;

import static java.nio.charset.StandardCharsets.UTF_8;

import java.io.*;
import java.math.BigInteger;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import java.net.*;
import java.nio.charset.StandardCharsets;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Signature;
import java.util.Scanner;
import AES.AES;
import Signature.RsaExample;

import java.util.Base64;
import java.util.Random;

import javax.crypto.spec.SecretKeySpec;

public class Client {
	public static void main(String[] args) {

		String encryptedInput;
		String decryptedStr;

		String secretKey;

		try {
			// Establish Connection
			Socket s = new Socket("localhost", 6000);
			DataInputStream dis = new DataInputStream(s.getInputStream());
			DataOutputStream dout = new DataOutputStream(s.getOutputStream());
			Scanner myInput = new Scanner(System.in);
			String input;

			// RSA
			int p_b, q_b, e_b, d_b, N_b;
			p_b = 5;
			q_b = 7;
			N_b = p_b * q_b; // 35
			e_b = 5;
			d_b = 29;

			int e_a, N_a; // (N_A,e_A) known to Bob
			N_a = 33;
			e_a = 3;
			
			System.out.println("\nRSA \nBob RSA Values p_a = " + p_b +"\n q_a = " + q_b +"\n N_a = " + N_b +"\n e_a = " + e_b +"\n d_a = " + d_b +
					"\nAlice RSA Values\n N_b = " + N_a +"\n e_b = " + e_a);

			// Diffie Hellman Key Exchange
			int b, g, ga, gb, m, k;
			g = 2;
			m = 2 ^ 2048 - 2 ^ 1984 - 1 + 2 ^ 64 * ((2 ^ 1918) + 124476);
			Random rand = new Random();
			b = rand.nextInt(30);
			gb = ((int) Math.pow(g, b)) % m;
			System.out.print("\nDiffie Hellman   \nb = " + b + " | g^b = " + gb);

			ga = dis.readInt();
			System.out.print(" | g^a = " + ga);
			dout.writeInt(gb);
			k = ((int) Math.pow(ga, b)) % m;
			System.out.println(" | DH Key (g^ba) = " + k);
			b = 0; // Destroy b

			secretKey = Integer.toString(k); // Diffe_Hellman key

			// Challenge
			int R_a, R_b;
			R_b = 5 * rand.nextInt(10) + 2;
			R_a = dis.readInt();
			dout.writeInt(R_b);
			System.out.print("\nChallenge-Response \n R_a = " + R_a + ",\t R_b = " + R_b);
			if (R_a % 10 == 1)
				System.out.println(",\nChallenge Verified");
			else {
				System.out.println(",\nChallenge Refused \nDisconnecting... ");
				System.exit(0);
			}
			// Hash
			String hash = "Alice" + "Bob" + R_a + R_b + ga + gb + k;
			System.out.println("\nHashCode Generated by SHA-256 for:  (" + hash + ") = " + toHexString(getSHA(hash)));

			
			// Signature
			String Sa,Sb;
			KeyPair pair = generateKeyPair();
			Sb = sign(hash+"Bob", pair.getPrivate());
			Sa = dis.readUTF();
			dout.writeUTF(Sb);
			System.out.println("\nSignature Exchange \nSb = " + Sb + "\nSa = " + Sa);
			//System.out.println("Verifing Alice Signature Sa = " + verify(Sa, hash+"Alice" , pair.getPublic()));

			
			// Secret Key Generator
			KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
			keyGenerator.init(128);
			SecretKey key = keyGenerator.generateKey();
			dout.writeUTF(keyToString(key));
			// secretKey = key.toString();
			System.out.println("\nAES Secret Key = " + key);

			
			// TicToc Initial Table
			String str = (String) dis.readUTF();
			System.out.println(str);

			// Game Starting (Start of session)
			for (int i = 0; i < 4; i++) {
				str = (String) dis.readUTF();
				decryptedStr = AES.decrypt(str, secretKey);
				System.out.println(decryptedStr);

				input = myInput.next();
				encryptedInput = AES.encrypt(input, secretKey);
				dout.writeUTF(encryptedInput);
			}

			str = (String) dis.readUTF();
			System.out.println(str);

			s.close();
			myInput.close();
		} catch (Exception e) {
			System.out.println(e);
		}
	}

	public static String keyToString(SecretKey secretKey) {
		byte encoded[] = secretKey.getEncoded();
		String encodedKey = Base64.getEncoder().encodeToString(encoded);
		return encodedKey;
	}

	public static SecretKey decodeKeyFromString(String keyStr) {
		byte[] decodedKey = Base64.getDecoder().decode(keyStr);
		SecretKey secretKey = new SecretKeySpec(decodedKey, 0, decodedKey.length, "AES");
		return secretKey;
	}

	public static byte[] getSHA(String input) throws NoSuchAlgorithmException {
		// Static getInstance method is called with hashing SHA
		MessageDigest md = MessageDigest.getInstance("SHA-256");
		// digest() method called
		// to calculate message digest of an input
		// and return array of byte
		return md.digest(input.getBytes(StandardCharsets.UTF_8));
	}

	public static String toHexString(byte[] hash) {
		// Convert byte array into signum representation
		BigInteger number = new BigInteger(1, hash);
		// Convert message digest into hex value
		StringBuilder hexString = new StringBuilder(number.toString(16));
		// Pad with leading zeros
		while (hexString.length() < 32) {
			hexString.insert(0, '0');
		}
		return hexString.toString();
	}

////////////////////////////   RSA     ///////////////////////////////
	public static KeyPair generateKeyPair() throws Exception {
		KeyPairGenerator generator = KeyPairGenerator.getInstance("RSA");
		generator.initialize(2048, new SecureRandom());
		KeyPair pair = generator.generateKeyPair();
		return pair;
	}

	public static KeyPair getKeyPairFromKeyStore() throws Exception {
		// Generated with:
		// keytool -genkeypair -alias mykey -storepass s3cr3t -keypass s3cr3t -keyalg
		// RSA -keystore keystore.jks

		InputStream ins = RsaExample.class.getResourceAsStream("/keystore.jks");
		KeyStore keyStore = KeyStore.getInstance("JCEKS");
		keyStore.load(ins, "s3cr3t".toCharArray()); // Keystore password
		KeyStore.PasswordProtection keyPassword = // Key password
				new KeyStore.PasswordProtection("s3cr3t".toCharArray());
		KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry) keyStore.getEntry("mykey", keyPassword);
		java.security.cert.Certificate cert = keyStore.getCertificate("mykey");
		PublicKey publicKey = cert.getPublicKey();
		PrivateKey privateKey = privateKeyEntry.getPrivateKey();
		return new KeyPair(publicKey, privateKey);
	}

	public static String encrypt(String plainText, PublicKey publicKey) throws Exception {
		Cipher encryptCipher = Cipher.getInstance("RSA");
		encryptCipher.init(Cipher.ENCRYPT_MODE, publicKey);
		byte[] cipherText = encryptCipher.doFinal(plainText.getBytes(UTF_8));
		return Base64.getEncoder().encodeToString(cipherText);
	}

	public static String decrypt(String cipherText, PrivateKey privateKey) throws Exception {
		byte[] bytes = Base64.getDecoder().decode(cipherText);
		Cipher decriptCipher = Cipher.getInstance("RSA");
		decriptCipher.init(Cipher.DECRYPT_MODE, privateKey);
		return new String(decriptCipher.doFinal(bytes), UTF_8);
	}

	public static String sign(String plainText, PrivateKey privateKey) throws Exception {
		Signature privateSignature = Signature.getInstance("SHA256withRSA");
		privateSignature.initSign(privateKey);
		privateSignature.update(plainText.getBytes(UTF_8));
		byte[] signature = privateSignature.sign();
		return Base64.getEncoder().encodeToString(signature);
	}

	public static boolean verify(String plainText, String signature, PublicKey publicKey) throws Exception {
		Signature publicSignature = Signature.getInstance("SHA256withRSA");
		publicSignature.initVerify(publicKey);
		publicSignature.update(plainText.getBytes(UTF_8));
		byte[] signatureBytes = Base64.getDecoder().decode(signature);
		return publicSignature.verify(signatureBytes);
	}
/////////////////////////////////////////////////////////////////////////
}
